{
  "name": "Albertxie博客-GitHub",
  "tagline": "Albert Xie",
  "body": "# 不疯魔，不成活\r\n－－－－－－－－－－－－－－Albert博客\r\n\r\n\r\n最近在做一个项目，用shell写的代码，但是在测试过程中，竟然发现了有内存泄露，百事不得其解，shell竟然也有内存泄露。\r\n之后查阅资料，唯一看到的一点就是在bash脚本中执行后台命令(加&)时，需要执行wait命令回收后台子进程的资源，否则会内存泄露。\r\n他给出的解释是：\r\n1、实际的内存泄露并不是被调用的后台进程自身产生的，泄露之处在于bash，bash调用后台命令，后台命令执行结束后，自身占用的资源(包括内存)应 该是成功回收的(bash中应该考虑了SIGCHLD信号的处理)，但问题关键在于：bash自己会为每一个后台子进程创建一个数据结构，用于保存后台进 程的返回值，否则bash中就无法了解后台子进程的退出状态了，这在一些情况下，确实是需要了解的。所以，泄露的内存就在这个数据结构上，如果不用 wait，那么每个后台子进程对应的数据结构就无法回收。\r\n2、理论上，泄露的数据结构应该很小，不会产生大的影响，但是另一个关键在于glibc的堆实现，如果死循环中不断的创建后台子进程，那就不断的会有相应 的数据结构分配，而其占用的内存很可能顶在了堆顶，我们知道，如果堆顶的内存不能回收，那么堆顶之下的内存也是不能回收的，所以由于该数据结构的泄露，可 能导致更大的内存泄露。经过分析故障当时bash进程的堆分布情况，确实可以确认这一点。\r\n（详细请看地址：http://blog.chinaunix.net/uid-29494093-id-4743981.html）\r\n\r\n虽然我在代码中也用到了死循环，但是并没有用到后台引用，显然不是我的问题所在，所以只好继续查阅资料，但是翻遍google，都没有相关的答案，那只好回过头仔细检阅代码了，依然无法发现问题，所以只好采用一个最笨的办法，一行一行注释代码，去发觉哪一行代码出现了这个情况，最后定位在local 定义变量的时候，一下给出示例代码：\r\n    #!/bin/bash\r\n    while true\r\n    do\r\n        local t\r\n    done\r\n这样就会内存泄露，我试着将local去掉，将他改成全局变量，竟然没漏了。\r\n由此我猜测：local 申请变量会动态的申请空间，类似与c 的malloc，在循环中不断的申请而没释放；二全局变量，应该存储在静态变量区，所以不存在问题。\r\n注意：函数中local申请的变量是会释放的，将它直接写在外部不会释放，　例如\r\n\r\n #!/bin/bash\r\n    mytest(){\r\n       local a\r\n    }\r\n    while true\r\n    do\r\n       mytest\r\n    done\r\n就不存在泄露。\r\n\r\n罗里吧嗦谢了这么多，感觉像记流水帐一样，第一次写，还是得多练练文笔",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}