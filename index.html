<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Albertxie博客-GitHub by AlbertXie0304</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Albertxie博客-GitHub</h1>
      <h2 class="project-tagline">Albert Xie</h2>
      <a href="https://github.com/AlbertXie0304/albertxie-blog" class="btn">View on GitHub</a>
      <a href="https://github.com/AlbertXie0304/albertxie-blog/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/AlbertXie0304/albertxie-blog/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="不疯魔不成活" class="anchor" href="#%E4%B8%8D%E7%96%AF%E9%AD%94%E4%B8%8D%E6%88%90%E6%B4%BB" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>不疯魔，不成活</h1>

<p>－－－－－－－－－－－－－－Albert博客</p>

<p>最近在做一个项目，用shell写的代码，但是在测试过程中，竟然发现了有内存泄露，百事不得其解，shell竟然也有内存泄露。
之后查阅资料，唯一看到的一点就是在bash脚本中执行后台命令(加&amp;)时，需要执行wait命令回收后台子进程的资源，否则会内存泄露。
他给出的解释是：
1、实际的内存泄露并不是被调用的后台进程自身产生的，泄露之处在于bash，bash调用后台命令，后台命令执行结束后，自身占用的资源(包括内存)应 该是成功回收的(bash中应该考虑了SIGCHLD信号的处理)，但问题关键在于：bash自己会为每一个后台子进程创建一个数据结构，用于保存后台进 程的返回值，否则bash中就无法了解后台子进程的退出状态了，这在一些情况下，确实是需要了解的。所以，泄露的内存就在这个数据结构上，如果不用 wait，那么每个后台子进程对应的数据结构就无法回收。
2、理论上，泄露的数据结构应该很小，不会产生大的影响，但是另一个关键在于glibc的堆实现，如果死循环中不断的创建后台子进程，那就不断的会有相应 的数据结构分配，而其占用的内存很可能顶在了堆顶，我们知道，如果堆顶的内存不能回收，那么堆顶之下的内存也是不能回收的，所以由于该数据结构的泄露，可 能导致更大的内存泄露。经过分析故障当时bash进程的堆分布情况，确实可以确认这一点。
（详细请看地址：<a href="http://blog.chinaunix.net/uid-29494093-id-4743981.html%EF%BC%89">http://blog.chinaunix.net/uid-29494093-id-4743981.html）</a></p>

<p>虽然我在代码中也用到了死循环，但是并没有用到后台引用，显然不是我的问题所在，所以只好继续查阅资料，但是翻遍google，都没有相关的答案，那只好回过头仔细检阅代码了，依然无法发现问题，所以只好采用一个最笨的办法，一行一行注释代码，去发觉哪一行代码出现了这个情况，最后定位在local 定义变量的时候，一下给出示例代码：
    #!/bin/bash
    while true
    do
        local t
    done
这样就会内存泄露，我试着将local去掉，将他改成全局变量，竟然没漏了。
由此我猜测：local 申请变量会动态的申请空间，类似与c 的malloc，在循环中不断的申请而没释放；二全局变量，应该存储在静态变量区，所以不存在问题。
注意：函数中local申请的变量是会释放的，将它直接写在外部不会释放，　例如</p>

<p>#!/bin/bash
    mytest(){
       local a
    }
    while true
    do
       mytest
    done
就不存在泄露。</p>

<p>罗里吧嗦谢了这么多，感觉像记流水帐一样，第一次写，还是得多练练文笔</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/AlbertXie0304/albertxie-blog">Albertxie博客-GitHub</a> is maintained by <a href="https://github.com/AlbertXie0304">AlbertXie0304</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
